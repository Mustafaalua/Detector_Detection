<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>functions.Detector_detection_functions.Detector_detection_functions &#8212; Detector Detection  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for functions.Detector_detection_functions.Detector_detection_functions</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">statistics</span>
<span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">skim</span>
<span class="kn">import</span> <span class="nn">skimage</span> <span class="k">as</span> <span class="nn">ski</span>
<span class="kn">from</span> <span class="nn">skimage.util</span> <span class="kn">import</span> <span class="n">invert</span>
<span class="kn">from</span> <span class="nn">dataObjects.ImageObject</span> <span class="kn">import</span> <span class="n">ImageObject</span>
<span class="kn">from</span> <span class="nn">dataObjects.Point</span> <span class="kn">import</span> <span class="n">Point</span>
<span class="kn">from</span> <span class="nn">dataObjects.enums.Direction</span> <span class="kn">import</span> <span class="n">Direction</span>
<span class="kn">from</span> <span class="nn">dataObjects.LinFunc</span> <span class="kn">import</span> <span class="n">LinFunc</span>
<span class="kn">from</span> <span class="nn">dataObjects.Square</span> <span class="kn">import</span> <span class="n">Square</span>
<span class="kn">from</span> <span class="nn">dataObjects.LinearFit</span> <span class="kn">import</span> <span class="n">LinearFit</span>
<span class="kn">from</span> <span class="nn">dataObjects.enums.Axis</span> <span class="kn">import</span> <span class="n">Axis</span>
<span class="kn">from</span> <span class="nn">dataObjects.enums.RowsAndColumns</span> <span class="kn">import</span> <span class="n">RowsAndColumns</span>
<span class="kn">from</span> <span class="nn">dataObjects.enums.ReaderType</span> <span class="kn">import</span> <span class="n">ReaderType</span>
<span class="kn">from</span> <span class="nn">models.interface.ImageReader</span> <span class="kn">import</span> <span class="n">ImageReader</span>
<span class="kn">from</span> <span class="nn">models.ReaderFactory</span> <span class="kn">import</span> <span class="n">ReaderFactory</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">linear_model</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="c1">#Functions used in Detector_detection.py</span>
<div class="viewcode-block" id="ShowImage">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.ShowImage">[docs]</a>
<span class="k">def</span> <span class="nf">ShowImage</span><span class="p">(</span><span class="n">im</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">,</span><span class="n">name</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Shows a choosen image with a custom title. If show progress is false then it wont be shown. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `im : ImageObject`</span>
<span class="sd">        the image object(`im`) that will be shown.</span>

<span class="sd">    `name : str`, optional</span>
<span class="sd">        the title above the image. `Default = &quot;&quot;`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `None`</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Black bared for readme</span>
    <span class="c1"># im = cv2.copyMakeBorder(src=im, top=100, bottom=100, left=100, right=100, borderType=cv2.BORDER_CONSTANT) </span>
    <span class="k">if</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SHOW_PROGRESS</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2"> :px&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> :px&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="ShowImages">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.ShowImages">[docs]</a>
<span class="k">def</span> <span class="nf">ShowImages</span><span class="p">(</span><span class="n">ims</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">ImageObject</span><span class="p">],</span><span class="n">names</span><span class="p">:[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Shows images with a custom title. If show progress is false then they wont be shown. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `ims : list[ImageObject]`</span>
<span class="sd">        the image objects(`ims`) that will be shown.</span>

<span class="sd">    `name : str`, optional</span>
<span class="sd">        the title above each image. `Default = &quot;&quot;`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `None`</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Create subplot split with the length of ims</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SHOW_PROGRESS</span><span class="p">):</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1">#Check if sizes add up</span>
        <span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)):</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">ims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">ims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2"> :px&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> :px&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="RemoveDots">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.RemoveDots">[docs]</a>
<span class="k">def</span> <span class="nf">RemoveDots</span><span class="p">(</span><span class="n">contours</span><span class="p">:</span><span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Remove contours that are under a specific area. Typically countours that are dot sized.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `contours : list`</span>
<span class="sd">        the contours to be searched through.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `list`</span>
<span class="sd">        a new list with the small/dot contours removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">newContours</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">areas</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
        <span class="c1">#Calculate area</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>

        <span class="c1">#Add</span>
        <span class="n">newContours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    
    <span class="n">areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>
    <span class="n">meanArea</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>

    <span class="c1">#meanArea = statistics.mean(areas) &lt;-- OLD</span>

    <span class="c1">#Filtering</span>
    <span class="n">filteredContours</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span>  <span class="n">meanArea</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">newContours</span><span class="p">))</span>

    <span class="c1">#Returning</span>
    <span class="k">return</span> <span class="n">filteredContours</span></div>

<div class="viewcode-block" id="RemoveEgdeContours">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.RemoveEgdeContours">[docs]</a>
<span class="k">def</span> <span class="nf">RemoveEgdeContours</span><span class="p">(</span><span class="n">contours</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span><span class="n">shape</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">pixelIncrement</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Goes through contours and removes the ones closest to the egde that do not form a complete square.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `contours : list`</span>
<span class="sd">        the contours to be searched through.</span>

<span class="sd">    `shape : np.ndarray`</span>
<span class="sd">        the shape(x,y) of the image where the contours were derived from.</span>
<span class="sd">        </span>
<span class="sd">    `pixelIncrement : int, optional`</span>
<span class="sd">        the increment from the egde of the image that should be removed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `list`</span>
<span class="sd">        a new list of contours with the egde cases removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Assuming y = 1104, x = 1176, will be removing by default 10 pixels in</span>
    
    <span class="c1">#Shape of image</span>
    <span class="n">xMax</span><span class="p">,</span><span class="n">yMax</span> <span class="o">=</span> <span class="n">shape</span>

    <span class="n">new_contours</span> <span class="o">=</span> <span class="p">[]</span> 

    <span class="c1">#No idea, followed: https://www.geeksforgeeks.org/find-co-ordinates-of-contours-using-opencv-python/</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
        <span class="c1">#Indications whether or not a contour should be added or not</span>
        <span class="n">removalMark</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="c1">#Dimensions of the contour</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">boundingRect</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="c1">#Checking all points</span>
        <span class="n">removalMark</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">pixelIncrement</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xMax</span> <span class="o">-</span> <span class="n">pixelIncrement</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">pixelIncrement</span> <span class="ow">or</span> <span class="p">(</span><span class="n">yMax</span> <span class="o">-</span> <span class="n">pixelIncrement</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span> 
        <span class="k">if</span><span class="p">(</span><span class="n">removalMark</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span> <span class="k">continue</span>

        <span class="c1">#Adding the width and height the get the next point</span>
        <span class="n">x</span><span class="o">+=</span><span class="n">w</span>
        <span class="n">y</span><span class="o">+=</span><span class="n">h</span>
        
        <span class="c1">#Checking again</span>
        <span class="n">removalMark</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">pixelIncrement</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xMax</span> <span class="o">-</span> <span class="n">pixelIncrement</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">pixelIncrement</span> <span class="ow">or</span> <span class="p">(</span><span class="n">yMax</span> <span class="o">-</span> <span class="n">pixelIncrement</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">removalMark</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span> <span class="k">continue</span>

        <span class="c1">#Add if it was never marked for removal</span>
        <span class="n">new_contours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_contours</span></div>

<div class="viewcode-block" id="Contouring">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.Contouring">[docs]</a>
<span class="k">def</span> <span class="nf">Contouring</span><span class="p">(</span><span class="n">imObj</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">,</span><span class="n">doThreshold</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Takes an image and returns contours derived from it.</span>

<span class="sd">    </span>
<span class="sd">    Extended Summary</span>
<span class="sd">    ----------</span>
<span class="sd">    All contours are derived and then egde and small contours are removed,\n</span>
<span class="sd">    leaving only whole contours that fill the grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `imObj : ImageObject`</span>
<span class="sd">        the image object(`imObj`) which the contours are derived from.</span>

<span class="sd">    `doThreshold : bool`, `optional`</span>
<span class="sd">        if the method should do the thresholding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `list`</span>
<span class="sd">        list of contours</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#As the methods used actually change the orignal image a copy will be created instead</span>
    <span class="n">im_clone</span> <span class="o">=</span> <span class="n">imObj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1">#Threshold created with values determine from canny egde testing</span>
    <span class="c1">#Find contours - values chosen with canny edge detection in mind - might need adjustment</span>
    <span class="k">if</span><span class="p">(</span><span class="n">doThreshold</span><span class="p">):</span>
        <span class="n">ret</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">im_clone</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">contours</span><span class="p">,</span> <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_NONE</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">contours</span><span class="p">,</span> <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">im_clone</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">RETR_LIST</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_NONE</span><span class="p">)</span>

    <span class="c1">#remove contours at the sides of the image that dont form a complete square</span>
    <span class="n">contours</span> <span class="o">=</span> <span class="n">RemoveEgdeContours</span><span class="p">(</span><span class="n">contours</span><span class="o">=</span><span class="n">contours</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="n">imObj</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="c1">#remove small unwanted contours that are not at the egde</span>
    <span class="n">contours</span> <span class="o">=</span> <span class="n">RemoveDots</span><span class="p">(</span><span class="n">contours</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">contours</span></div>

<div class="viewcode-block" id="AdjustToGrid">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.AdjustToGrid">[docs]</a>
<span class="k">def</span> <span class="nf">AdjustToGrid</span><span class="p">(</span><span class="n">contours</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span><span class="n">axis</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">limit</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Takes an unordered list of contours and orders them based on x,y and axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `contours : list`</span>
<span class="sd">        the unordered list of `contours`</span>

<span class="sd">    `axis : int`, `optional` </span>
<span class="sd">        the axis at which to order the the contours, for x-axis = 1, for y-axis = 0</span>
<span class="sd">    </span>
<span class="sd">    `limit : int`, `optional`</span>
<span class="sd">        the `limit` is used to combat variations along the x and y axis of the contours.\n</span>
<span class="sd">        For `axis` = 0 then `limit` = 25 is recommended. \n</span>
<span class="sd">        For `axis` = 1 then `limit` = 15 is recommended.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `tuple[list,int]`</span>
<span class="sd">        a tuple with the ordered list of contours and a int for amount of valid rows</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Create empty numpy array that fits the amount of contours</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">contours</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">coords</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


    <span class="c1">#List to hold x and y values and index will match contours</span>
    <span class="n">indexList</span><span class="p">:</span> <span class="nb">list</span><span class="p">([</span><span class="nb">int</span><span class="p">,</span><span class="nb">int</span><span class="p">])</span> <span class="o">=</span>  <span class="p">[]</span>

    <span class="c1">#Save coords</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">contours</span><span class="p">)):</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">contours</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
        <span class="n">indexList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span>

    <span class="c1">#Change some pixel values to make them fit eachother, some values are next to eachother on the grid but is slighty higher or lower by one/two pixels</span>
    <span class="c1">#Which messes up the ordering of the grid contours</span>
    
    <span class="c1">#Where to start the change</span>
    <span class="n">startChange</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1">#Where to apply change x = 0 and y = 1, this changes the sorting order and limit has to accounted. Try limit = 20 for y and limit = 5 for x</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>

    <span class="c1">#Where to end the change</span>
    <span class="n">endChange</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1">#Applied change</span>
    <span class="n">change</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1">#Limit to determine which values to apply change to</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
    
    <span class="c1">#Index to make it adjustable outside of the loops influence</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#Rows that are valid in the grid - used for another method so it might aswell be returned now instead of trying to find it again</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#Sort coords based on y and x</span>
    <span class="k">if</span><span class="p">(</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="c1">#Sort for x first then y</span>
        <span class="n">sortedCoords</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#Sort for y first then x</span>
        <span class="n">sortedCoords</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>


    <span class="c1">#Extra column to hold old and new.       </span>
    <span class="c1">#Old have positions x=[0] and y=[1], new have x=[2] and y=[3]</span>
    <span class="n">extraColumn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sortedCoords</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">extraColumn</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1">#Keep old values as they are needed to reverse the change after the sorting. We cant match the values with a contour if we dont reverse.</span>
    <span class="n">reverseCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sortedCoords</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="n">extraColumn</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sortedCoords</span><span class="p">)):</span>
        <span class="c1">#Take out the first value and check all the values after it is still within a limit</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">sortedCoords</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span>

        <span class="c1">#Where change is starting</span>
        <span class="n">startChange</span> <span class="o">=</span> <span class="n">index</span>

        <span class="c1">#upper limit for y values that are accepted</span>
        <span class="n">upperLimit</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="n">limit</span>

        <span class="c1">#lower limit for y values that are accepted</span>
        <span class="n">lowerLimit</span> <span class="o">=</span> <span class="n">value</span> <span class="o">-</span> <span class="n">limit</span>

        <span class="c1">#New loop to search ahead in the current 2d array and determine an endChange</span>
        <span class="c1">#Set index to our know startChange plus 1 as the precise startChange is our baseline  </span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">startChange</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">sortedCoords</span><span class="p">)):</span>
            
            <span class="c1">#Evaluate</span>
            <span class="nb">eval</span> <span class="o">=</span> <span class="n">sortedCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> 
            <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">lowerLimit</span> <span class="o">&lt;=</span> <span class="nb">eval</span> <span class="o">&amp;</span> <span class="nb">eval</span> <span class="o">&lt;=</span> <span class="n">upperLimit</span><span class="p">)</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedCoords</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1">#If here then values have exceeded limit</span>
                    
                <span class="c1">#j was exceeded and therefore the value just before was inside, this will be handled by range()</span>
                <span class="n">endChange</span> <span class="o">=</span> <span class="n">j</span>
                <span class="k">break</span>

        <span class="c1">#redundant but name makes more sense at this point</span>
        <span class="n">change</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1">#Sequence</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">startChange</span><span class="p">,</span><span class="n">endChange</span><span class="p">)</span>

        <span class="c1">#loop through startChange until endChange and apply change</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
            
            <span class="c1">#Change y value</span>
            <span class="n">sortedCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">change</span>

            <span class="c1">#Save new value</span>
            <span class="c1">#x</span>
            <span class="n">reverseCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sortedCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#y</span>
            <span class="n">reverseCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">sortedCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1">#Set next starting point and apply rows for i=0</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">endChange</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">startChange</span> <span class="o">=</span> <span class="n">endChange</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">startChange</span>


        <span class="c1">#Check if changes has reached its end as we dont always know the size of the grid before hand, so we use the whole length of the 2d array</span>
        <span class="k">if</span><span class="p">(</span><span class="n">startChange</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedCoords</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

            <span class="c1">#Last number is an egde case </span>
            <span class="n">sortedCoords</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">change</span>

            <span class="c1">#Save new value</span>
            <span class="c1">#x</span>
            <span class="n">reverseCoords</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sortedCoords</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#y</span>
            <span class="n">reverseCoords</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">sortedCoords</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">break</span>

    <span class="c1">#Sort again based on y and x</span>
    <span class="k">if</span><span class="p">(</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="c1">#Sort for x first then y</span>
        <span class="n">correctSortedCoords</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sortedCoords</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#Sort for y first then x</span>
        <span class="n">correctSortedCoords</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sortedCoords</span><span class="p">),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    
    <span class="n">correctSortedCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">correctSortedCoords</span><span class="p">)</span>


    <span class="c1">#Reverse</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reverseCoords</span><span class="p">)):</span>
        <span class="c1">#Since correctSortedCoords has been changed, we need to change it back by comparing new values with eachother and overwrite with the old</span>
        <span class="c1">#Therefore will the order remain the same but the values will change back and then we can compare the values back to their orignal contour</span>

        <span class="c1">#Extract values - can be improved</span>
        <span class="n">oldX</span> <span class="o">=</span> <span class="n">reverseCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">oldY</span> <span class="o">=</span> <span class="n">reverseCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">newX</span> <span class="o">=</span> <span class="n">reverseCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">newY</span> <span class="o">=</span> <span class="n">reverseCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1">#Compare</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">correctSortedCoords</span><span class="p">)):</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">correctSortedCoords</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">newX</span> <span class="ow">and</span> <span class="n">correctSortedCoords</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">newY</span><span class="p">):</span>
                <span class="c1">#Change back</span>
                <span class="n">correctSortedCoords</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldX</span>
                <span class="n">correctSortedCoords</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldY</span>
                <span class="k">break</span>
       

    <span class="c1">#Clone/Copy of orignal array</span>
    <span class="n">contourCopy</span> <span class="o">=</span> <span class="n">contours</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1">#Create new contour array but in order</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sortedCoords</span><span class="p">)):</span>
        <span class="c1">#Extract every array</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">correctSortedCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">correctSortedCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1">#Search index and save index</span>
        <span class="n">sortingIndex</span> <span class="o">=</span> <span class="n">indexList</span><span class="o">.</span><span class="n">index</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span>

        <span class="c1">#Move all information from one contour to the correct place instead of the first x and y only</span>
        <span class="n">contourCopy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">contours</span><span class="p">[</span><span class="n">sortingIndex</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">contourCopy</span><span class="p">,</span><span class="n">rows</span></div>

<div class="viewcode-block" id="TranslatePixeltoMM">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.TranslatePixeltoMM">[docs]</a>
<span class="k">def</span> <span class="nf">TranslatePixeltoMM</span><span class="p">(</span><span class="n">realPixelLength</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span><span class="n">pixelLength</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Translates a pixel length to millimeters using a known pixel size. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `realPixelLength : float`</span>
<span class="sd">        the size of a pixel in the real world in millimeters.</span>

<span class="sd">    `pixelLength : float`</span>
<span class="sd">        the amount of pixels to be translated to millimeters.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `float`</span>
<span class="sd">        the length as millimeters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#units:</span>
    <span class="c1">#         px       *        mm</span>
    <span class="c1">#         -------------------- ??????????</span>
    <span class="c1">#                  mm</span>
    <span class="k">return</span> <span class="n">pixelLength</span> <span class="o">*</span> <span class="n">realPixelLength</span> </div>

<div class="viewcode-block" id="FindMagnification">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.FindMagnification">[docs]</a>
<span class="k">def</span> <span class="nf">FindMagnification</span><span class="p">(</span><span class="n">imObj</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Determines the magnification of an image by assuming it is a mesh/grid image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `imObj : ImageObject`</span>
<span class="sd">        the image object(`imObj`) that will be used to calculated the magnification.</span>
<span class="sd">       </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `float`</span>
<span class="sd">        the calculated magnification</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Threshold</span>
    <span class="n">medianblur</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">medianBlur</span><span class="p">(</span><span class="n">imObj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">invMedianBlur</span> <span class="o">=</span> <span class="n">invert</span><span class="p">(</span><span class="n">medianblur</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span><span class="n">binInvBlur</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">invMedianBlur</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mf">255.0</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">THRESH_BINARY</span><span class="p">)</span>

    <span class="c1">#Resize</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">imObj</span><span class="o">.</span><span class="n">shape</span> <span class="o">*</span> <span class="n">imObj</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span>
    <span class="n">resizedImg</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">binInvBlur</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span>

    <span class="c1">#Insert into image object</span>
    <span class="n">resizedImg</span> <span class="o">=</span> <span class="n">ImageObject</span><span class="p">(</span><span class="n">resizedImg</span><span class="p">,</span><span class="n">imObj</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span><span class="n">imObj</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>

    <span class="c1">#Define squares with contours</span>
    <span class="n">contours</span> <span class="o">=</span> <span class="n">Contouring</span><span class="p">(</span><span class="n">resizedImg</span><span class="p">,</span><span class="n">doThreshold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1">#Sort</span>
    <span class="n">sortedContours</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">AdjustToGrid</span><span class="p">(</span><span class="n">contours</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">limit</span><span class="o">=</span><span class="mi">25</span><span class="o">*</span><span class="n">resizedImg</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span><span class="p">)</span>
    
    <span class="c1">#Find center point for each sqaure</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="n">sortedContours</span><span class="p">]</span>

    <span class="c1">#Map points so they have references to eachother</span>
    <span class="n">MapPoints</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">imObj</span><span class="p">)</span>

    <span class="c1">#Use points to create big squares formed from 4 center points together</span>
    <span class="n">sq</span> <span class="o">=</span> <span class="n">CreatingSquares</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    
    <span class="c1">#Save centerPoints between intersections</span>
    <span class="n">centerPoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">GetCenterPoint</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sq</span><span class="p">]</span> 

    <span class="c1">#Fit sqaure</span>
    <span class="n">MapPoints</span><span class="p">(</span><span class="n">centerPoints</span><span class="p">,</span><span class="n">imObj</span><span class="p">)</span>
    
    <span class="c1">#Fits a square on the image with a certain amount of rows and columns</span>
    <span class="n">vertices</span><span class="p">,</span><span class="n">rows</span><span class="p">,</span><span class="n">columns</span> <span class="o">=</span> <span class="n">FitSquare</span><span class="p">(</span><span class="n">centerPoints</span><span class="p">,</span><span class="n">resizedImg</span><span class="p">)</span>

    <span class="c1">#Create blank</span>
    <span class="n">blank</span> <span class="o">=</span> <span class="n">resizedImg</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">*</span> <span class="mi">0</span>

    <span class="c1">#Convert to numpy to use method</span>
    <span class="n">vertices_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

    <span class="c1">#Fill sqaure</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">blank</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">*</span> <span class="mi">0</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">fillPoly</span><span class="p">(</span><span class="n">b</span><span class="p">,[</span><span class="n">vertices_np</span><span class="p">],</span><span class="mi">255</span><span class="p">)</span>

    <span class="c1">#Show points and their number</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>  
        <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">blank</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">,(</span><span class="mi">125</span><span class="p">,</span><span class="mi">125</span><span class="p">,</span><span class="mi">125</span><span class="p">),</span><span class="mi">7</span><span class="o">*</span><span class="n">resizedImg</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span><span class="p">)</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span><span class="n">blank</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">resizedImg</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span><span class="o">*</span><span class="mi">2</span><span class="p">,(</span><span class="mi">125</span><span class="p">,</span><span class="mi">125</span><span class="p">,</span><span class="mi">125</span><span class="p">),</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1">#Calculate area</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">vertices_np</span><span class="p">)</span>

    <span class="c1">#Scale down</span>
    <span class="n">areaScaledDown</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="p">(</span><span class="n">resizedImg</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span> <span class="o">*</span> <span class="n">resizedImg</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span><span class="p">)</span>

    <span class="c1">#Calculate amount of squares</span>
    <span class="n">amountOfSquares</span> <span class="o">=</span> <span class="n">rows</span><span class="o">*</span><span class="n">columns</span>
    <span class="k">if</span><span class="p">(</span><span class="n">amountOfSquares</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">amountOfSquares</span> <span class="o">=</span> <span class="n">columns</span>

    <span class="c1">#Calculate average Area per sqaure</span>
    <span class="n">averageAreaPrSqr</span> <span class="o">=</span> <span class="n">areaScaledDown</span><span class="o">/</span><span class="n">amountOfSquares</span>

    <span class="c1">#Calculate length from averageAreaPrSqr</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">averageAreaPrSqr</span><span class="p">)</span> 

    <span class="c1">#Calculate magnification for specific image</span>
    <span class="n">magnification</span> <span class="o">=</span> <span class="p">(</span><span class="n">TranslatePixeltoMM</span><span class="p">(</span><span class="n">resizedImg</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SINGLE_PIXEL_SIZE_MILLIMETER</span><span class="p">,</span><span class="n">length</span><span class="p">))</span><span class="o">/</span><span class="n">resizedImg</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">GRID_MILLIMETER_LENGTH</span> <span class="c1">#+- 1</span>

    <span class="c1">#Add length and magnification to calculate dsd later</span>
    <span class="n">imObj</span><span class="o">.</span><span class="n">SetMagnification</span><span class="p">(</span><span class="n">magnification</span><span class="p">)</span>

    <span class="c1">#ShowImages([blank,b])</span>

    <span class="k">return</span> <span class="n">magnification</span></div>

<div class="viewcode-block" id="FindTranslation">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.FindTranslation">[docs]</a>
<span class="k">def</span> <span class="nf">FindTranslation</span><span class="p">(</span><span class="n">pointIm1</span><span class="p">:</span><span class="n">Point</span><span class="p">,</span><span class="n">pointIm2</span><span class="p">:</span><span class="n">Point</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Finds a translation(difference) between two points(x,y), assuming that they are comparable.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `pointIm1 : Point`</span>
<span class="sd">        point object that contains `x` and `y` for image 1</span>

<span class="sd">    `pointIm2 : Point`</span>
<span class="sd">        point object that contains `x` and `y` for image 2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `np.ndarray`</span>
<span class="sd">        a 3x2 numpy array that can be applied directly as a warp matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Create output warp matrix</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1">#break down points into respective x and y values</span>
    <span class="n">xIm1</span><span class="p">,</span><span class="n">yIm1</span> <span class="o">=</span> <span class="p">[</span><span class="n">pointIm1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">pointIm1</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>
    <span class="n">xIm2</span><span class="p">,</span><span class="n">yIm2</span> <span class="o">=</span> <span class="p">[</span><span class="n">pointIm2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">pointIm2</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>

    <span class="c1">#Calculate translation</span>
    <span class="n">xTranslation</span> <span class="o">=</span> <span class="n">xIm2</span> <span class="o">-</span> <span class="n">xIm1</span>
    <span class="n">yTranslation</span> <span class="o">=</span> <span class="n">yIm2</span> <span class="o">-</span> <span class="n">yIm1</span>

    <span class="c1">#Insert into matrix</span>
    <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xTranslation</span>
    <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">yTranslation</span>

    <span class="k">return</span> <span class="n">matrix</span></div>

<div class="viewcode-block" id="AddSpacePrint">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.AddSpacePrint">[docs]</a>
<span class="k">def</span> <span class="nf">AddSpacePrint</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Adds 5 spaces to making printing look nicer</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `None`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CreatingSquares">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.CreatingSquares">[docs]</a>
<span class="k">def</span> <span class="nf">CreatingSquares</span><span class="p">(</span><span class="n">points</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Square</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Takes a series of points, finds 4 points that make out a square and returns all squares found.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `points : list[Point]`</span>
<span class="sd">        the list of points that are going to be used to create squares.  </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `list[Square]`</span>
<span class="sd">        returns the list of all the created squares.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Using built in point left, right, above and under to identitfy squares </span>
    <span class="n">sq</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#Go through every point and try to create a sqaure from the information inside the point object</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        <span class="c1">#p is always upperLeftCorner</span>
        <span class="c1">#below p is always lowerLeftCorner</span>

        <span class="c1">#right for p is always upperRightCorner</span>
        <span class="c1">#under &quot;right&quot; is always lowerRightCorner</span>

        <span class="c1">#Points at the egdes might not have below or right points and therefore will throw an exception</span>
        <span class="n">upperLeftCorner</span> <span class="o">=</span> <span class="n">p</span> 

        <span class="c1">#Check under</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">under</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span> <span class="k">continue</span>
        <span class="n">lowerLeftCorner</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">under</span>

        <span class="c1">#Check right</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span> <span class="k">continue</span>
        <span class="n">upperRightCorner</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">right</span>

        <span class="c1">#Check under right</span>
        <span class="k">if</span><span class="p">(</span><span class="n">upperRightCorner</span><span class="o">.</span><span class="n">under</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span> <span class="k">continue</span>
        <span class="n">lowerRightCorner</span> <span class="o">=</span> <span class="n">upperRightCorner</span><span class="o">.</span><span class="n">under</span>


        <span class="c1">#Create sqaure</span>
        <span class="n">square</span> <span class="o">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">upperRightCorner</span><span class="p">,</span><span class="n">upperLeftCorner</span><span class="p">,</span><span class="n">lowerRightCorner</span><span class="p">,</span><span class="n">lowerLeftCorner</span><span class="p">)</span>
        
        <span class="c1">#Append</span>
        <span class="n">sq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sq</span></div>

<div class="viewcode-block" id="FitSquare">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.FitSquare">[docs]</a>
<span class="k">def</span> <span class="nf">FitSquare</span><span class="p">(</span><span class="n">centerPoints</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">],</span><span class="n">imObj</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">list</span><span class="p">[(</span><span class="nb">int</span><span class="p">,</span><span class="nb">int</span><span class="p">)],</span><span class="nb">int</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Takes a series of points and maps them to eachother with built-in directions.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `points : list[Point]`</span>
<span class="sd">        the list of points that are going to be mapped to eachother. </span>

<span class="sd">    `imObj : ImageObject`</span>
<span class="sd">        the image object that the points are derived from to map according to distance and scale. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `None`</span>
<span class="sd">        returns none, the `Point` attributes with directions are changed inside the list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Lists to hold the points that will form the different lines</span>
    <span class="n">UpperHoriLine</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">LowerHoriLine</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">LeftVertiLine</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">RightVertiLine</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#Starting point</span>
    <span class="n">p</span><span class="p">:</span><span class="n">Point</span> <span class="o">=</span> <span class="n">centerPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">#Counter to determine best rows</span>
    <span class="n">outerCounter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">innerCounter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#Starting with upper horizontal line </span>
    <span class="c1"># - outer</span>
    <span class="n">p1</span><span class="p">:</span><span class="n">Point</span> <span class="o">=</span> <span class="n">centerPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1">#Check</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">right</span>
            <span class="n">outerCounter</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">outerCounter</span><span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># - inner</span>
    <span class="n">p2</span><span class="p">:</span><span class="n">Point</span> <span class="o">=</span> <span class="n">centerPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">under</span>
        
    <span class="c1">#Check</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p2</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">right</span>
            <span class="n">innerCounter</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">innerCounter</span> <span class="o">+=</span><span class="mi">1</span>
    
    <span class="c1">#Evaluate the inner and outer to eachother and use</span>
    <span class="k">if</span><span class="p">(</span><span class="n">outerCounter</span> <span class="o">&lt;</span> <span class="n">innerCounter</span><span class="p">):</span>
        <span class="c1">#Use inner point as reference</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">centerPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">under</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">innerCounter</span>            

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#Use outer point as reference</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">centerPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">outerCounter</span>


    <span class="c1">#Count columns with for loop</span>
    <span class="n">highPColumns</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pColumns</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">counterColumns</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#Add the highest point from every column</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
        <span class="n">highPColumns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">right</span>
    
    <span class="c1">#Go through every highest point for every columns and find the points under</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">highPColumns</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">point</span>
        <span class="n">pColumn</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">#Add points until there are no more points under</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">under</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">under</span>
            <span class="n">pColumn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="c1">#Insert point into the first position</span>
        <span class="n">pColumn</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">point</span><span class="p">)</span>

        <span class="c1">#Add ponts to a collective list</span>
        <span class="n">pColumns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pColumn</span><span class="p">)</span>

        <span class="c1">#Add the length to another list to use mode</span>
        <span class="n">counterColumns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pColumn</span><span class="p">))</span>
    

    <span class="c1">#Find mode</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">counterColumns</span><span class="p">)</span>

    <span class="c1">#Cut off for the beginnig and ending, ex 1-5 where index 0 is remove. 1 through 5 must have the same amount of points as mode.</span>
    <span class="n">startCutOff</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">endCutOff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pColumns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1">#Evalaute every column by size</span>
    <span class="c1">#for i in range(0,endCutOff+1): #CHANGE TO WHILE for(i = 0; i &lt; endCutOff+1; i++)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">endCutOff</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="c1">#pColumn can be larger, the same or smaller.</span>

        <span class="c1">#the same -&gt; do nothing</span>
        
        <span class="c1">#Larger</span>
        <span class="k">if</span><span class="p">(</span><span class="n">counterColumns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mode</span><span class="p">):</span>
            
            <span class="c1">#Take the difference and reduce pColumn until it matches the mode</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">counterColumns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">mode</span>

            <span class="c1">#Remove the last elements with indices</span>
            <span class="n">pColumns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pColumns</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="o">-</span><span class="n">diff</span><span class="p">]</span> <span class="c1">#DO NOT IF THIS ACTUALLY WORKS</span>

        <span class="c1">#Smaller</span>
        <span class="k">elif</span><span class="p">(</span><span class="n">counterColumns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mode</span><span class="p">):</span>

            <span class="c1">#There two cases here. if i is at the cutcoff numbers then we remove that part of the list</span>
            <span class="c1">#If it is within the start and endcutoff then we reduce every element to fit with the current list</span>
            
            <span class="c1">#At the cutoff</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">startCutOff</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">endCutOff</span><span class="p">):</span>
                <span class="c1">#Remove elements</span>
                <span class="k">del</span> <span class="n">pColumns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">counterColumns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="c1">#Set cutoff again</span>
                <span class="n">startCutOff</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">endCutOff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pColumns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1">#Inside cutoff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#Reduce the size of every pColumn list from </span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pColumns</span><span class="p">)):</span>
                    
                    <span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pColumns</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">counterColumns</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                        <span class="k">del</span> <span class="n">pColumns</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">counterColumns</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pColumns</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                
                <span class="c1">#Readjust mode</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">counterColumns</span><span class="p">)</span>
        
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1">##################################### EXTRAPOLATION ROWS ########################################################</span>
    <span class="c1">#Amount of columns determines the amount of points on each row there is</span>
    <span class="n">IsRowsExtrapolated</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pColumns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">):</span> 
        <span class="c1">#Since we dont have a list for rows like we do for columns, we have to create it -&gt; right to left </span>

        <span class="c1">#Creating rows list from columns - the mode is equal to how many rows there are</span>
        <span class="n">pRows</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
            
            <span class="n">pRow</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">pColumns</span><span class="p">:</span>
                <span class="n">pRow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">pRows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pRow</span><span class="p">)</span>

        <span class="c1">#Create fits based on points being columns or rows -&gt; Rows</span>
        <span class="n">linearFits</span> <span class="o">=</span> <span class="n">CreateFits</span><span class="p">(</span><span class="n">pRows</span><span class="p">,</span><span class="n">imObj</span><span class="p">,</span><span class="n">RowsAndColumns</span><span class="o">.</span><span class="n">ROWS</span><span class="p">)</span>

        <span class="c1">#Extrapolate rows</span>
        <span class="n">holderPoints</span> <span class="o">=</span> <span class="n">ExtrapolateRowsOrColumns</span><span class="p">(</span><span class="n">pRows</span><span class="p">,</span><span class="n">linearFits</span><span class="p">,</span><span class="n">centerPoints</span><span class="p">,</span><span class="n">RowsAndColumns</span><span class="o">.</span><span class="n">ROWS</span><span class="p">)</span>
       
        <span class="c1">###################################### REDO MAPING(adjust points) ###########################################</span>
        <span class="n">MapPoints</span><span class="p">(</span><span class="n">holderPoints</span><span class="p">,</span><span class="n">imObj</span><span class="p">)</span>

        <span class="c1">#Extrapoled has been done and therefore redoing </span>
        <span class="n">IsRowsExtrapolated</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="c1">#Use mode to redo columns later on - can be done with min()</span>
        <span class="n">modeRows</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pRows</span><span class="p">)</span>

    <span class="c1">##################################### EXTRAPOLATION COLUMNS ########################################################</span>
    <span class="c1">#Only makes sense to do fit if columns have more than 2 points</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mode</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">):</span>
        
        <span class="c1">#Redo columns since they have been extrapolted</span>
        <span class="k">if</span><span class="p">(</span><span class="n">IsRowsExtrapolated</span><span class="p">):</span>
            <span class="c1">#Clear Columns()</span>
            <span class="n">pColumns</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

            <span class="c1">#Creating columns list from rows - the mode is equal to how many columns there are</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">modeRows</span><span class="p">):</span>
            
                <span class="n">pColumn</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">pr</span> <span class="ow">in</span> <span class="n">pRows</span><span class="p">:</span>
                    <span class="n">pColumn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="n">pColumns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pColumn</span><span class="p">)</span>
            

        <span class="c1">#Create fits based on points being columns or rows -&gt; Columns</span>
        <span class="n">linearFits</span> <span class="o">=</span> <span class="n">CreateFits</span><span class="p">(</span><span class="n">pColumns</span><span class="p">,</span><span class="n">imObj</span><span class="p">,</span><span class="n">RowsAndColumns</span><span class="o">.</span><span class="n">COLUMNS</span><span class="p">)</span>

        <span class="c1">#Extrapolate columns</span>
        <span class="n">holderPoints</span> <span class="o">=</span> <span class="n">ExtrapolateRowsOrColumns</span><span class="p">(</span><span class="n">pColumns</span><span class="p">,</span><span class="n">linearFits</span><span class="p">,</span><span class="n">centerPoints</span><span class="p">,</span><span class="n">RowsAndColumns</span><span class="o">.</span><span class="n">COLUMNS</span><span class="p">)</span>
       
        <span class="c1">###################################### REDO MAPING(adjust points) ###########################################</span>
        <span class="n">MapPoints</span><span class="p">(</span><span class="n">holderPoints</span><span class="p">,</span><span class="n">imObj</span><span class="p">)</span>

    
    <span class="c1">#Find corners</span>
    <span class="c1">#First column used to extract left side corner</span>
    <span class="n">upperLeftCorner</span><span class="p">:</span><span class="n">Point</span> <span class="o">=</span> <span class="n">pColumns</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lowerLeftCorner</span><span class="p">:</span><span class="n">Point</span> <span class="o">=</span> <span class="n">pColumns</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1">#Last column used to extract right side corner</span>
    <span class="n">upperRightCorner</span><span class="p">:</span><span class="n">Point</span> <span class="o">=</span> <span class="n">pColumns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lowerRightCorner</span><span class="p">:</span><span class="n">Point</span> <span class="o">=</span> <span class="n">pColumns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


    <span class="c1">#Only the horizontal lines should be formed as the columns is already formed - could do this before the corners</span>
    <span class="n">LeftVertiLine</span> <span class="o">=</span> <span class="n">pColumns</span><span class="p">[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">RightVertiLine</span> <span class="o">=</span> <span class="n">pColumns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


    <span class="c1">#Upper horizontal line</span>
    <span class="n">UpperHoriLine</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">upperLeftCorner</span>
    <span class="n">UpperHoriLine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">right</span>
        <span class="n">UpperHoriLine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="c1">#Check if p is the end corner, as a point to the right of the corner can be cutoff</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">upperRightCorner</span><span class="p">):</span> <span class="k">break</span>


    <span class="c1">#Lower horizontal line</span>
    <span class="n">LowerHoriLine</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">lowerRightCorner</span>
    <span class="n">LowerHoriLine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">left</span>
        <span class="n">LowerHoriLine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="c1">#Check if p is the end corner, as a point to the right of the corner can be cutoff</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">lowerLeftCorner</span><span class="p">):</span><span class="k">break</span>

    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">UpperHoriLine</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">LowerHoriLine</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">RightVertiLine</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">LeftVertiLine</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">UpperHoriLine</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">LowerHoriLine</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">RightVertiLine</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">LeftVertiLine</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1">#Combine lists</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">UpperHoriLine</span> <span class="o">+</span> <span class="n">RightVertiLine</span> <span class="o">+</span> <span class="n">LowerHoriLine</span> <span class="o">+</span> <span class="n">LeftVertiLine</span>


    <span class="c1">#Removing duplicates with dict and turning back to list </span>
    <span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>


    <span class="c1">#Break down points object into ints</span>
    <span class="n">vertrices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        <span class="n">vertrices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>

    <span class="c1">#Return</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">RightVertiLine</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">UpperHoriLine</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">vertrices</span><span class="p">,</span><span class="n">rows</span><span class="p">,</span><span class="n">columns</span></div>

<div class="viewcode-block" id="MapPoints">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.MapPoints">[docs]</a>
<span class="k">def</span> <span class="nf">MapPoints</span><span class="p">(</span><span class="n">points</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">],</span><span class="n">imObj</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Takes a series of points and maps them to eachother with built-in directions.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `points : list[Point]`</span>
<span class="sd">        the list of points that are going to be mapped to eachother. </span>

<span class="sd">    `imObj : ImageObject`</span>
<span class="sd">        the image object that the points are derived from to map according to distance and scale. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `None`</span>
<span class="sd">        returns none, the `Point` attributes with directions are changed inside the list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Extract scale and distance</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">imObj</span><span class="o">.</span><span class="n">distance</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">imObj</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span>

    <span class="c1">#Variance is for how many pixels we go out to still determine a point as part of a line</span>
    <span class="c1">#Is done with this linear fit: Y = 0.3576*X + 41.00</span>
    <span class="n">pxDistance</span> <span class="o">=</span> <span class="mf">0.3576</span> <span class="o">*</span> <span class="n">distance</span> <span class="o">+</span> <span class="mi">41</span>

    <span class="n">pxDistance</span> <span class="o">*=</span><span class="n">scale</span>

    <span class="n">variance</span> <span class="o">=</span> <span class="n">pxDistance</span> <span class="o">*</span> <span class="mf">0.35</span>

    <span class="c1">#go through every point</span>
    <span class="k">for</span> <span class="n">center</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        
        <span class="c1">#Center coords </span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">y</span>

        <span class="c1">#Limit to determine same vertical line</span>
        <span class="n">upperXLimit</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">variance</span>
        <span class="n">lowerXLimit</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">variance</span>

        <span class="c1">#Limit to determine same horizontal line</span>
        <span class="n">upperYLimit</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">variance</span>
        <span class="n">lowerYLimit</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">variance</span>

        <span class="c1">#Check if above has already been set</span>
        <span class="k">if</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">above</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1">#Find above - comparing y values and checking with x ####################################</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="mi">9999</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>

                <span class="c1">#Skip if center and neighbor is the same</span>
                <span class="k">if</span><span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="n">neighbor</span><span class="p">):</span> <span class="k">continue</span>    

                <span class="n">Nx</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">x</span>
                <span class="n">Ny</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">y</span>

                <span class="c1">#If difference is a positive number, it means that neighbor is above</span>
                <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">Ny</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

                    <span class="c1">#Check that neighbor and center is on the same vertical line</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">lowerXLimit</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="ow">and</span> <span class="n">Nx</span> <span class="o">&lt;</span> <span class="n">upperXLimit</span><span class="p">):</span>
                        
                        <span class="c1">#Lastly check if its a lower number than the threshold that came before it</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">threshold</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">-</span> <span class="n">Ny</span><span class="p">):</span>
                            <span class="n">candidate</span> <span class="o">=</span> <span class="n">neighbor</span>
                            <span class="n">threshold</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">Ny</span>

            <span class="c1">#Adding the candidate whether its None or a Point</span>
            <span class="n">center</span><span class="o">.</span><span class="n">AddNeighboringPoints</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span><span class="n">Direction</span><span class="o">.</span><span class="n">ABOVE</span><span class="p">)</span>

        <span class="c1">#Check if under has already been set</span>
        <span class="k">if</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">under</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1">#Find under - comparing y values and checking with x ####################################</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9999</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>

                <span class="c1">#Skip if center and neighbor is the same</span>
                <span class="k">if</span><span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="n">neighbor</span><span class="p">):</span> <span class="k">continue</span>    

                <span class="n">Nx</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">x</span>
                <span class="n">Ny</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">y</span>

                <span class="c1">#If difference is a negative number, it means that neighbor is under</span>
                <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">Ny</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>

                    <span class="c1">#Check that neighbor and center is on the same vertical line</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">lowerXLimit</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="ow">and</span> <span class="n">Nx</span> <span class="o">&lt;</span> <span class="n">upperXLimit</span><span class="p">):</span>
                        
                        <span class="c1">#Lastly check if its a higher number than the threshold that came before it</span>
                        <span class="c1">#We want the negative number closest to zero</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">threshold</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">-</span> <span class="n">Ny</span><span class="p">):</span> 
                            <span class="n">candidate</span> <span class="o">=</span> <span class="n">neighbor</span>
                            <span class="n">threshold</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">Ny</span>

            <span class="c1">#Adding the candidate whether its None or a Point</span>
            <span class="n">center</span><span class="o">.</span><span class="n">AddNeighboringPoints</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span><span class="n">Direction</span><span class="o">.</span><span class="n">UNDER</span><span class="p">)</span>
        
        <span class="c1">#Check if left has already been set</span>
        <span class="k">if</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1">#Find left - comparing x values and checking with y ####################################</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="mi">9999</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>

                <span class="c1">#Skip if center and neighbor is the same</span>
                <span class="k">if</span><span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="n">neighbor</span><span class="p">):</span> <span class="k">continue</span>    

                <span class="n">Nx</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">x</span>
                <span class="n">Ny</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">y</span>

                <span class="c1">#If difference is a positive number, it means that neighbor is to the left</span>
                <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">Nx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

                    <span class="c1">#Check that neighbor and center is on the same horizontal line</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">lowerYLimit</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="ow">and</span> <span class="n">Ny</span> <span class="o">&lt;</span> <span class="n">upperYLimit</span><span class="p">):</span>
                        
                        <span class="c1">#Lastly check if its a lower number than the threshold that came before it</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">threshold</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">-</span> <span class="n">Nx</span><span class="p">):</span>
                            <span class="n">candidate</span> <span class="o">=</span> <span class="n">neighbor</span>
                            <span class="n">threshold</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">Nx</span>

            <span class="c1">#Adding the candidate whether its None or a Point</span>
            <span class="n">center</span><span class="o">.</span><span class="n">AddNeighboringPoints</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span><span class="n">Direction</span><span class="o">.</span><span class="n">LEFT</span><span class="p">)</span>

        <span class="c1">#Check if right has already been set</span>
        <span class="k">if</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1">#Find right - comparing x values and checking with y ####################################</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9999</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>

                <span class="c1">#Skip if center and neighbor is the same</span>
                <span class="k">if</span><span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="n">neighbor</span><span class="p">):</span> <span class="k">continue</span>    

                <span class="n">Nx</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">x</span>
                <span class="n">Ny</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">y</span>

                <span class="c1">#If difference is a negative number, it means that neighbor is under</span>
                <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">Nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>

                    <span class="c1">#Check that neighbor and center is on the same vertical line</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">lowerYLimit</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="ow">and</span> <span class="n">Ny</span> <span class="o">&lt;</span> <span class="n">upperYLimit</span><span class="p">):</span>
                        
                        <span class="c1">#Lastly check if its a higher number than the threshold that came before it</span>
                        <span class="c1">#We want the negative number closest to zero</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">threshold</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">-</span> <span class="n">Nx</span><span class="p">):</span> 
                            <span class="n">candidate</span> <span class="o">=</span> <span class="n">neighbor</span>
                            <span class="n">threshold</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">Nx</span>

            <span class="c1">#Adding the candidate whether its None or a Point</span>
            <span class="n">center</span><span class="o">.</span><span class="n">AddNeighboringPoints</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span><span class="n">Direction</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProcessDSD">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.ProcessDSD">[docs]</a>
<span class="k">def</span> <span class="nf">ProcessDSD</span><span class="p">(</span><span class="n">imageObjects</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">ImageObject</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Takes a series of image objects and calculates DSD, DSD variance and DSD standard deviation.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `imageObjects : list[ImageObject]`</span>
<span class="sd">        image objects where the DSD is going to be derived from. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `tuple[float,float,float]`</span>
<span class="sd">        a tuple with 3 numbers being DSD, DSD variance and DSD standard deviation in that order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1. Find Magnification of both images, which is returned as a float</span>
    <span class="c1">#Lengths used to do the calculations</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">zeroSquareElements</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">imageObjects</span><span class="p">)):</span>    
        <span class="c1">#FindMagnification(imageObjects[k],SINGLE_PIXEL_SIZE,GRID_MM_LENGTH) &lt;--- OLD</span>

        <span class="c1">#Threshold</span>
        <span class="n">medianblur</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">medianBlur</span><span class="p">(</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">invMedianBlur</span> <span class="o">=</span> <span class="n">invert</span><span class="p">(</span><span class="n">medianblur</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span><span class="n">binInvBlur</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">invMedianBlur</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mf">255.0</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">THRESH_BINARY</span><span class="p">)</span>

        <span class="c1">#Resize</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">*</span> <span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span>
        <span class="n">resizedImg</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">binInvBlur</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span>

        <span class="c1">#Insert into image object</span>
        <span class="n">resizedImg</span> <span class="o">=</span> <span class="n">ImageObject</span><span class="p">(</span><span class="n">resizedImg</span><span class="p">,</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>

        <span class="c1">#Define squares with contours</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">Contouring</span><span class="p">(</span><span class="n">resizedImg</span><span class="p">,</span><span class="n">doThreshold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1">#Sort</span>
        <span class="n">sortedContours</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">AdjustToGrid</span><span class="p">(</span><span class="n">contours</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">limit</span><span class="o">=</span><span class="mi">25</span><span class="o">*</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span><span class="p">)</span>

        <span class="c1">#region points for loop</span>
        <span class="c1"># #Find point for each sqaure</span>
        <span class="c1"># points = []</span>
        <span class="c1"># for j in range(len(sortedContours)):</span>
        <span class="c1">#     x,y = np.mean(sortedContours[j],axis=0)[0]</span>

        <span class="c1">#     points.append(Point(x,y))</span>

        <span class="c1">#     cv2.circle(resizedImg.image, (int(x),int(y)), radius=0, color=(255, 255, 255), thickness=7*scale)</span>
        <span class="c1">#endregion</span>
        
        <span class="c1">#Find center point for each sqaure</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="n">sortedContours</span><span class="p">]</span>

        <span class="c1">#Map points so they have references to eachother</span>
        <span class="n">MapPoints</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="c1">#Use points to create big squares formed from 4 center points together</span>
        <span class="n">sq</span> <span class="o">=</span> <span class="n">CreatingSquares</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1">#region centerPoints for loop</span>
        <span class="c1"># centerPoints = []</span>
        <span class="c1"># #Save center point</span>
        <span class="c1"># for j in range(len(sq)):</span>
        <span class="c1">#     intersec = sq[j].GetCenterPoint()</span>

        <span class="c1">#     centerPoints.append(intersec)</span>

        <span class="c1">#     #cv2.putText(resizedImg,f&quot;{i}&quot;,(int(intersec.x)-50,int(intersec.y)),1,scale*2,(0,0,0),4)</span>
        <span class="c1">#     #print(intersec)</span>

        <span class="c1">#     cv2.circle(resizedImg.image,(int(intersec.x),int(intersec.y)),0,(125,125,125),7*scale)</span>
        <span class="c1">#endregion</span>
        
        <span class="c1">#Save centerPoints between intersections</span>
        <span class="n">centerPoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">GetCenterPoint</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sq</span><span class="p">]</span> 

        <span class="c1">#Fit sqaure</span>
        <span class="n">MapPoints</span><span class="p">(</span><span class="n">centerPoints</span><span class="p">,</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="c1">#Fits a square on the image with a certain amount of rows and columns</span>
        <span class="n">vertices</span><span class="p">,</span><span class="n">rows</span><span class="p">,</span><span class="n">columns</span> <span class="o">=</span> <span class="n">FitSquare</span><span class="p">(</span><span class="n">centerPoints</span><span class="p">,</span><span class="n">resizedImg</span><span class="p">)</span>

        <span class="c1">#Check if rows and columns are zero then continue</span>
        <span class="k">if</span><span class="p">(</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">columns</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">zeroSquareElements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">continue</span>

        <span class="c1">#Create blank</span>
        <span class="n">blank</span> <span class="o">=</span> <span class="n">resizedImg</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">*</span> <span class="mi">0</span>

        <span class="c1">#Convert to numpy to use method</span>
        <span class="n">vertices_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

        <span class="c1">#Fill sqaure</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">blank</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">*</span> <span class="mi">0</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">fillPoly</span><span class="p">(</span><span class="n">b</span><span class="p">,[</span><span class="n">vertices_np</span><span class="p">],</span><span class="mi">255</span><span class="p">)</span>

        <span class="c1">#Show points and their number</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>  
            <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">blank</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">,(</span><span class="mi">125</span><span class="p">,</span><span class="mi">125</span><span class="p">,</span><span class="mi">125</span><span class="p">),</span><span class="mi">7</span><span class="o">*</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span><span class="p">)</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span><span class="n">blank</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span><span class="o">*</span><span class="mi">2</span><span class="p">,(</span><span class="mi">125</span><span class="p">,</span><span class="mi">125</span><span class="p">,</span><span class="mi">125</span><span class="p">),</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1">#Calculate area</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">vertices_np</span><span class="p">)</span>

        <span class="c1">#Scale down</span>
        <span class="n">areaScaledDown</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="p">(</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span> <span class="o">*</span> <span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SCALE</span><span class="p">)</span>

        <span class="c1">#Calculate amount of squares</span>
        <span class="n">amountOfSquares</span> <span class="o">=</span> <span class="n">rows</span><span class="o">*</span><span class="n">columns</span>
        <span class="k">if</span><span class="p">(</span><span class="n">amountOfSquares</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">amountOfSquares</span> <span class="o">=</span> <span class="n">columns</span>

        <span class="c1">#Calculate average Area per sqaure</span>
        <span class="n">averageAreaPrSqr</span> <span class="o">=</span> <span class="n">areaScaledDown</span><span class="o">/</span><span class="n">amountOfSquares</span>

        <span class="c1">#Calculate length from averageAreaPrSqr</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">averageAreaPrSqr</span><span class="p">)</span> 

        <span class="c1">#Calculate magnification for specific image</span>
        <span class="n">magnification</span> <span class="o">=</span> <span class="p">(</span><span class="n">TranslatePixeltoMM</span><span class="p">(</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SINGLE_PIXEL_SIZE_MILLIMETER</span><span class="p">,</span><span class="n">length</span><span class="p">))</span><span class="o">/</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">GRID_MILLIMETER_LENGTH</span> <span class="c1">#+- 1</span>

        <span class="c1">#Printing information, can be removed</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;k: &quot;</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;row: &quot;</span><span class="p">,</span><span class="n">rows</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;column: &quot;</span><span class="p">,</span><span class="n">columns</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;area scaled down: &quot;</span> <span class="p">,</span><span class="n">areaScaledDown</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;average area per sqr: &quot;</span><span class="p">,</span><span class="n">averageAreaPrSqr</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;length: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">averageAreaPrSqr</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mag: &quot;</span><span class="p">,</span><span class="n">magnification</span><span class="p">)</span>
        <span class="c1">#ShowImages([resizedImg.image,blank,b],[f&quot;resized: {imageObjects[k].distance}&quot;,&quot;points&quot;,&quot;area&quot;])</span>
        <span class="n">AddSpacePrint</span><span class="p">()</span>

        <span class="c1">#Add length and magnification to calculate dsd later</span>
        <span class="n">imageObjects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">SetMagnification</span><span class="p">(</span><span class="n">magnification</span><span class="p">)</span>
        <span class="n">lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">length</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>


    <span class="c1">#Remove zero square elements</span>
    <span class="k">for</span> <span class="n">imObj</span> <span class="ow">in</span> <span class="n">zeroSquareElements</span><span class="p">:</span>
        <span class="n">imageObjects</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">imObj</span><span class="p">)</span>


    <span class="c1">#Baseline - baseline being the smallest distance</span>
    <span class="n">baselineLength</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">baselineDistance</span> <span class="o">=</span> <span class="n">imageObjects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">distance</span>

    <span class="c1">#Run through and calculate the dsd for each</span>
    <span class="n">dsdHolder</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">imageObjects</span><span class="p">)):</span><span class="c1">#Skip index=0</span>
        <span class="n">dsd</span> <span class="o">=</span> <span class="p">(</span><span class="n">imageObjects</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">distance</span> <span class="o">-</span> <span class="n">baselineDistance</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">baselineLength</span><span class="p">)</span><span class="o">/</span><span class="n">baselineLength</span><span class="p">)</span> <span class="o">-</span> <span class="n">baselineDistance</span>
        <span class="n">dsdHolder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dsd</span><span class="p">)</span>

    <span class="c1">#=(88-48)/((72.08-57.68)/57.68)-48)</span>
    <span class="c1">#dsd = (88 - baselineDistance)/((72.08 - baselineLength)/baselineLength) - baselineDistance</span>
    <span class="c1">#       ^distance eval             ^length eval</span>

    <span class="c1">#Convert numbers to numpy array</span>
    <span class="n">dsdHolder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dsdHolder</span><span class="p">)</span>

    <span class="c1">#Take median as reference for dsd</span>
    <span class="n">dsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dsdHolder</span><span class="p">)</span>
    
    <span class="n">dsdVar</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">dsdHolder</span><span class="p">)</span>

    <span class="n">dsdSigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dsdVar</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dsd</span><span class="p">,</span><span class="n">dsdVar</span><span class="p">,</span><span class="n">dsdSigma</span></div>

<div class="viewcode-block" id="CreateFits">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.CreateFits">[docs]</a>
<span class="k">def</span> <span class="nf">CreateFits</span><span class="p">(</span><span class="n">pCR</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]],</span><span class="n">imObj</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">,</span><span class="n">rowsOrColumns</span><span class="p">:</span><span class="n">RowsAndColumns</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">LinearFit</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description</span>
<span class="sd">    ----------</span>
<span class="sd">    Create linear fits for rows or columns.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `pCR : list[list[Point]]`</span>
<span class="sd">        2d list where the first index indicate a row or column and the second index indicate the specific </span>
<span class="sd">         point within the row or column.</span>

<span class="sd">    `imObj : ImageObject`</span>
<span class="sd">        image object where the rows or columns are derived from. </span>

<span class="sd">    `rowsOrColumns : RowsAndColumns`</span>
<span class="sd">        enum that indicate whether `pCR` are rows or columns.    </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `list[LinearFit]`</span>
<span class="sd">        list of the linear fit that matches the `pCR` list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Columns -&gt; distanceUnder </span>
    <span class="c1">#Rows -&gt; distanceRight</span>

    <span class="c1">#List of fits and their information</span>
    <span class="n">linearFits</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">LinearFit</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#To hold x values</span>
    <span class="n">xList</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#To hold y values</span>
    <span class="n">yList</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#To hold distance so a step can be calculated</span>
    <span class="n">step</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#Depending on rowsOrColumns the approach is different</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rowsOrColumns</span> <span class="o">==</span> <span class="n">RowsAndColumns</span><span class="o">.</span><span class="n">COLUMNS</span><span class="p">):</span>
        <span class="c1">#Set axis</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">Axis</span><span class="o">.</span><span class="n">Y</span>

        <span class="c1">#Take each column and do linear regression</span>
        <span class="k">for</span> <span class="n">pcr</span> <span class="ow">in</span> <span class="n">pCR</span><span class="p">:</span>
            
            <span class="c1">#Extract x,y and distance and place into list and convert to numpy array later</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcr</span><span class="p">:</span>
                <span class="n">xList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">yList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">step</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">distanceToUnder</span><span class="p">)</span>

            <span class="c1">#Remove lastest step as it always 0.0 </span>
            <span class="n">step</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="c1">#Place into numpy array - invert since its vertical - so: x = y  a + b</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xList</span><span class="p">)</span> <span class="c1"># x depends on y</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">yList</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># y does not depend on anything</span>

            <span class="c1">#Calculate median step to extrapolation</span>
            <span class="n">medianStep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">step</span><span class="p">))</span>

            <span class="c1">#Fit</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LinearRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
            
            <span class="c1">#Finding r</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> 

            <span class="c1">#region show fit on image</span>
            <span class="c1">#Show on image</span>
            <span class="c1"># y_pred = np.array(list(range(0,imObj.shape[1]+1))).reshape(-1,1) #IS ACTUALLY Y VALUES ON CV2 PLOT AXIS</span>
            <span class="c1"># x_pred = fit.predict(y_pred) #IS ACTUALLY X VALUES ON CV2 PLOT AXIS</span>
            <span class="c1"># for ii in range(0,imObj.shape[1]+1):</span>
            <span class="c1">#     cv2.circle(imObj.image,(int(x_pred[ii]),int(y_pred[ii])),0,(0),1)</span>
            <span class="c1"># plt.plot(x_pred,y_pred) #show plot</span>
            <span class="c1">#endregion</span>

            <span class="c1">#Extract upper y value</span>
            <span class="n">upEvalY</span> <span class="o">=</span> <span class="n">pcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1">#Apparently they are reference and not static...</span>

            <span class="c1">#Extract lower y value </span>
            <span class="n">lowEvalY</span> <span class="o">=</span> <span class="n">pcr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1">#Apparently they are reference and not static...</span>

            <span class="c1">#Create linearfit</span>
            <span class="n">linearFits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LinearFit</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span><span class="n">medianStep</span><span class="p">,</span><span class="n">upEvalY</span><span class="p">,</span><span class="n">lowEvalY</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">pcr</span><span class="p">,</span><span class="n">imObj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">axis</span><span class="p">))</span>

            <span class="c1">#Reset</span>
            <span class="n">xList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">yList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">step</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">elif</span><span class="p">(</span><span class="n">rowsOrColumns</span> <span class="o">==</span> <span class="n">RowsAndColumns</span><span class="o">.</span><span class="n">ROWS</span><span class="p">):</span>
        <span class="c1">#Set axis</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">Axis</span><span class="o">.</span><span class="n">X</span>

        <span class="c1">#Take each row and do linear regression</span>
        <span class="k">for</span> <span class="n">pcr</span> <span class="ow">in</span> <span class="n">pCR</span><span class="p">:</span>
            
            <span class="c1">#Extract x,y and distance and place into list and convert to numpy array later</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcr</span><span class="p">:</span>
                <span class="n">xList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">yList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">step</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">distanceToRight</span><span class="p">)</span>

            <span class="c1">#Remove lastest step as it is always 0.0 </span>
            <span class="n">step</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="c1">#Place into numpy array - invert since its vertical - so: y = x  a + b</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">yList</span><span class="p">)</span> <span class="c1"># y depends on x</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xList</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># x does not depend on anything</span>

            <span class="c1">#Calculate median step to extrapolation</span>
            <span class="n">medianStep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">step</span><span class="p">))</span>

            <span class="c1">#Fit</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LinearRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            
            <span class="c1">#Finding r</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> 

            <span class="c1">#region show fit on image</span>
            <span class="c1"># x_pred = np.array(list(range(0,imObj.shape[0]+1))).reshape(-1,1) #IS ACTUALLY Y VALUES ON CV2 PLOT AXIS</span>
            <span class="c1"># y_pred = fit.predict(x_pred) #IS ACTUALLY X VALUES ON CV2 PLOT AXIS</span>
            <span class="c1"># for ii in range(0,imObj.shape[0]+1):</span>
            <span class="c1">#     cv2.circle(imObj.image,(int(x_pred[ii]),int(y_pred[ii])),0,(0),1)</span>
            <span class="c1"># plt.plot(x_pred,y_pred) #show plot</span>
            <span class="c1">#endregion</span>

            <span class="c1">#Extract upper x value</span>
            <span class="n">upEvalY</span> <span class="o">=</span> <span class="n">pcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1">#Apparently they are reference and not static...</span>

            <span class="c1">#Extract lower y value</span>
            <span class="n">lowEvalY</span> <span class="o">=</span> <span class="n">pcr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1">#Apparently they are reference and not static...</span>

            <span class="c1">#Create linearfit</span>
            <span class="n">linearFits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LinearFit</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span><span class="n">medianStep</span><span class="p">,</span><span class="n">upEvalY</span><span class="p">,</span><span class="n">lowEvalY</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">pcr</span><span class="p">,</span><span class="n">imObj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">axis</span><span class="p">))</span>

            <span class="c1">#Reset</span>
            <span class="n">xList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">yList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">step</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="n">linearFits</span>    </div>

<div class="viewcode-block" id="ExtrapolateRowsOrColumns">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.ExtrapolateRowsOrColumns">[docs]</a>
<span class="k">def</span> <span class="nf">ExtrapolateRowsOrColumns</span><span class="p">(</span><span class="n">pCR</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]],</span><span class="n">linearFits</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">LinearFit</span><span class="p">],</span><span class="n">points</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">],</span><span class="n">rowsOrColumns</span><span class="p">:</span><span class="n">RowsAndColumns</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extrapolate rows or columns based on linear fits.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `pCR : list[list[Point]]`</span>
<span class="sd">        2d list where the first index indicate a row or column and the second index indicate the specific point within the row or column.</span>

<span class="sd">    `linearFits : list[LinearFit]`</span>
<span class="sd">        linear fits that are derived from the rows or columns and element-wise should match the first index of `pCR`. </span>

<span class="sd">    `points : list[Point]`</span>
<span class="sd">        list of the points that already are on image so extrapolated points can be added to it.</span>

<span class="sd">    `rowsOrColumns : RowsAndColumns`</span>
<span class="sd">        enum that indicate whether `pCR` are rows or columns.    </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `list[Point]`</span>
<span class="sd">        a copy of `points` with the extrapolated points added to it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Go through each linear fit and check how many times we extrapolate upwards and downwards</span>
    <span class="n">countsUp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">countsDown</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">fit</span> <span class="ow">in</span> <span class="n">linearFits</span><span class="p">:</span>
        <span class="n">countsUp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">availableUpper</span><span class="p">))</span>
        <span class="n">countsDown</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">availableLower</span><span class="p">))</span>

    <span class="c1">#Use set and take lowest number as reference to how many times we can extrapolate in a uniform manner</span>
    <span class="n">minUp</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">countsUp</span><span class="p">)</span> 
    <span class="n">minDown</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">countsDown</span><span class="p">)</span>

    <span class="c1">#Holder to add new points to and to do remaping</span>
    <span class="n">holderPoints</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1">#Process depends on if its rows or columns</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rowsOrColumns</span> <span class="o">==</span> <span class="n">RowsAndColumns</span><span class="o">.</span><span class="n">COLUMNS</span><span class="p">):</span>

        <span class="c1">#Do for both upper and lower</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">linearFits</span><span class="p">)):</span>
            
            <span class="c1">#Do for upper (or lower if you consider actual y values and not the image) </span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">minUp</span><span class="p">):</span>
                
                <span class="c1">#Take prediction out of linearFit</span>
                <span class="n">newPoint</span> <span class="o">=</span> <span class="n">linearFits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">availableUpper</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

                <span class="c1">#Insert into specific column - make first element</span>
                <span class="n">pCR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">newPoint</span><span class="p">)</span>
                
                <span class="c1">#holder Points to remap</span>
                <span class="n">holderPoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newPoint</span><span class="p">)</span>
            
            <span class="c1">#Do for lower (or upper if you consider actual y values and not the image)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">minDown</span><span class="p">):</span>

                <span class="c1">#Take prediction out of linearFit</span>
                <span class="n">newPoint</span> <span class="o">=</span> <span class="n">linearFits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">availableLower</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

                <span class="c1">#Insert into specific column - make last</span>
                <span class="n">pCR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newPoint</span><span class="p">)</span>
                
                <span class="c1">#holder Points to remap</span>
                <span class="n">holderPoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newPoint</span><span class="p">)</span>

    <span class="k">elif</span><span class="p">(</span><span class="n">rowsOrColumns</span> <span class="o">==</span> <span class="n">RowsAndColumns</span><span class="o">.</span><span class="n">ROWS</span><span class="p">):</span>
        <span class="c1">#Do for both upper and lower</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">linearFits</span><span class="p">)):</span>
            
            <span class="c1">#Do for upper (or lower if you consider actual y values and not the image) </span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">minUp</span><span class="p">):</span>
                
                <span class="c1">#Take prediction out of linearFit</span>
                <span class="n">newPoint</span> <span class="o">=</span> <span class="n">linearFits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">availableUpper</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

                <span class="c1">#Insert into specific row - make first element</span>
                <span class="n">pCR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">newPoint</span><span class="p">)</span>
               
                <span class="c1">#holder Points to remap</span>
                <span class="n">holderPoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newPoint</span><span class="p">)</span>
            
            <span class="c1">#Do for lower (or upper if you consider actual y values and not the image)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">minDown</span><span class="p">):</span>

                <span class="c1">#Take prediction out of linearFit</span>
                <span class="n">newPoint</span> <span class="o">=</span> <span class="n">linearFits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">availableLower</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

                <span class="c1">#Insert into specific row - make last</span>
                <span class="n">pCR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newPoint</span><span class="p">)</span>

                <span class="c1">#holder Points to remap</span>
                <span class="n">holderPoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newPoint</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">holderPoints</span></div>

<div class="viewcode-block" id="CreateMagnificationMatrix">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.CreateMagnificationMatrix">[docs]</a>
<span class="k">def</span> <span class="nf">CreateMagnificationMatrix</span><span class="p">(</span><span class="n">imObj1</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">,</span><span class="n">imObj2</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes two `ImageObject` and finds the magnification matrix to match the two images magnification-wise.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `imObj1 : ImageObject`</span>
<span class="sd">        the image object to be scaled to match `imObj2`.</span>

<span class="sd">    `imObj2 : ImageObject`</span>
<span class="sd">        the image object that `imObj1` has to match magnification-wise. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `np.ndarray`</span>
<span class="sd">        the translation matrix to overlap `imObj1Scaled` with `imObj2`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Percentage difference between two images</span>
    <span class="n">percentage</span> <span class="o">=</span> <span class="p">((</span><span class="n">imObj2</span><span class="o">.</span><span class="n">magnification</span><span class="o">-</span><span class="n">imObj1</span><span class="o">.</span><span class="n">magnification</span><span class="p">)</span><span class="o">/</span><span class="n">imObj1</span><span class="o">.</span><span class="n">magnification</span><span class="p">)</span>

    <span class="c1">#DSD = FindDSD(percentage,Distances[ii]-Distances[i]) &lt;- old</span>

    <span class="c1">#Use the percentage change to apply a affine matrix to change the scale and at the same time keep the image centered (for image1)</span>
    <span class="n">appliedScale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">percentage</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1">#Create identity matrix</span>
    <span class="c1">#Positions for scale are x = [0,0] and y = [1,1]. Positions for translation are x = [0,2] and y = [1,2]</span>
    <span class="n">warpScaleMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1">#Scale</span>
    <span class="n">warpScaleMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">appliedScale</span>
    <span class="n">warpScaleMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">appliedScale</span>

    <span class="c1">#Apply percentage change to the x and y so it can used in the translation part of the matrix and keep it centered</span>
    <span class="n">xApplied</span> <span class="o">=</span> <span class="n">imObj1</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">appliedScale</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">yApplied</span> <span class="o">=</span> <span class="n">imObj1</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">appliedScale</span><span class="o">/</span><span class="mi">2</span>

    <span class="c1">#translation - this reason for it being -= is because we are always going from small to larger distance, so 0 mm to 200 mm which will always require </span>
    <span class="c1">#a scaling up and therefore the y and x will increase and we mitigate this by subtracting x/y applied</span>
    <span class="c1">#If we reverse the process so 200 mm to 0 mm then we would be scaling down and therefore += is needed</span>
    <span class="n">warpScaleMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">xApplied</span>
    <span class="n">warpScaleMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">yApplied</span>

    <span class="k">return</span> <span class="n">warpScaleMatrix</span></div>

<div class="viewcode-block" id="ProcessShift">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.ProcessShift">[docs]</a>
<span class="k">def</span> <span class="nf">ProcessShift</span><span class="p">(</span><span class="n">imObj1Scaled</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">,</span><span class="n">imObj2</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes two `ImageObject` and finds a common spot between them and process the shift needed to overlap the two images.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `imObj1Scaled : ImageObject`</span>
<span class="sd">        the image object scaled to match `imObj2` and shift will overlap `imObj1Scaled` with `imObj2`.</span>

<span class="sd">    `imObj2 : ImageObject`</span>
<span class="sd">        the image object that `imObj1Scaled` has to match. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `np.ndarray`</span>
<span class="sd">        the translation matrix to overlap `imObj1Scaled` with `imObj2`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#With the imaged up/down the next step is to find the offset(translation) and magnification(scale) that will change image1 to fit onto image2</span>
    <span class="c1">#Find comparable points for both im1 and im2</span>
    <span class="n">pointIm1S</span> <span class="o">=</span> <span class="n">FindCenterHole</span><span class="p">(</span><span class="n">imObj1Scaled</span><span class="p">)</span>
    <span class="n">pointIm2</span> <span class="o">=</span> <span class="n">FindCenterHole</span><span class="p">(</span><span class="n">imObj2</span><span class="p">)</span>

    <span class="c1">#Find translation based on the given points</span>
    <span class="n">warp_mat_calc</span> <span class="o">=</span> <span class="n">FindTranslation</span><span class="p">(</span><span class="n">pointIm1S</span><span class="p">,</span><span class="n">pointIm2</span><span class="p">)</span>

    <span class="c1">#Warp with the found translation</span>
    <span class="n">imObj1Scaled</span><span class="o">.</span><span class="n">WarpSelf</span><span class="p">(</span><span class="n">warp_mat_calc</span><span class="p">)</span>

    <span class="n">ShowImages</span><span class="p">([</span><span class="n">imObj1Scaled</span><span class="p">,</span><span class="n">imObj2</span><span class="p">,</span><span class="n">ImageObject</span><span class="p">(</span><span class="n">imObj2</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">imObj1Scaled</span><span class="o">.</span><span class="n">image</span><span class="p">,</span><span class="n">imObj2</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span><span class="n">imObj2</span><span class="o">.</span><span class="n">settings</span><span class="p">)],[</span><span class="sa">f</span><span class="s2">&quot;Scaled up image (</span><span class="si">{</span><span class="n">imObj1Scaled</span><span class="o">.</span><span class="n">distance</span><span class="si">}</span><span class="s2"> mm)&quot;</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;Image (</span><span class="si">{</span><span class="n">imObj2</span><span class="o">.</span><span class="n">distance</span><span class="si">}</span><span class="s2"> mm)&quot;</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;Difference between of the two images&quot;</span><span class="p">])</span>

    <span class="c1">#Use the findtransform ecc to match the images and give a translation, it has a tougher time with large difference so we did some scaling up and translation for it</span>
    <span class="c1">#So it should only do a translation ideally which would be a small translation(adjustment only)</span>

    <span class="c1">#Define the motion model - allowing the method to use a complete MOTION_AFFINE messes up the final image as it would want to apply shear and scale </span>
    <span class="n">warp_mode</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">MOTION_AFFINE</span>
    <span class="c1">#warp_mode = cv2.MOTION_TRANSLATION</span>
   
    <span class="c1">#Define 2x3 matrix and initialize the matrix to identity matrix I (eye)</span>
    <span class="c1">#[1     0       0]</span>
    <span class="c1">#[0     1       0]</span>
    <span class="n">warp_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1">#specify the number of iterations </span>
    <span class="n">number_of_iterations</span> <span class="o">=</span> <span class="mi">5000</span>

    <span class="c1">#Sepcifiy the threshold of the increment</span>
    <span class="c1">#in the correlation coefficient between two iterations</span>
    <span class="n">termination_eps</span> <span class="o">=</span> <span class="mf">1e-3</span>

    <span class="c1">#Define termination criteria</span>
    <span class="n">criteria</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">TermCriteria_EPS</span> <span class="o">|</span> <span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_COUNT</span><span class="p">,</span> <span class="n">number_of_iterations</span><span class="p">,</span> <span class="n">termination_eps</span><span class="p">)</span>

    <span class="c1">#Run the ECC algorithm. The results are stored in warp_matrix.</span>
    <span class="c1">#ECC = Enchanced Correlation Coefficient Maximization</span>
    <span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">warp_matrix</span><span class="p">)</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findTransformECC</span><span class="p">(</span><span class="n">imObj1Scaled</span><span class="o">.</span><span class="n">image</span><span class="p">,</span><span class="n">imObj2</span><span class="o">.</span><span class="n">image</span><span class="p">,</span><span class="n">warp_matrix</span><span class="p">,</span><span class="n">warp_mode</span><span class="p">,</span><span class="n">criteria</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">#Warp im1 using affine</span>
    <span class="n">imObj1Scaled</span><span class="o">.</span><span class="n">WarpSelf</span><span class="p">(</span><span class="n">warp_matrix</span><span class="p">)</span>
    <span class="c1">#region how the warp matrix works:</span>
    <span class="c1">#Affine warp matrix: </span>
    <span class="c1">#                     A = [a_00  a_01]          B = [b_00]</span>
    <span class="c1">#                         [a_10  a_11]              [b_10]</span>
    <span class="c1">#</span>
    <span class="c1">#                     M = [A B] = [a_00  a_01  b_00]</span>
    <span class="c1">#                                 [a_10  a_11  b_10]</span>
    <span class="c1">#</span>
    <span class="c1">#                         scale x   shear y  translation x</span>
    <span class="c1">#                     T = [a_00*x   a_01*y   b_00]</span>
    <span class="c1">#                         [a_10*x   a_11*y   b_10]</span>
    <span class="c1">#                         shear x   scale y  translation y</span>
    <span class="c1">#</span>
    <span class="c1">#Translation warp matrix: [1  0  t_x]</span>
    <span class="c1">#                         [0  1  t_y]</span>
    <span class="c1">#endregion</span>
    
    <span class="c1">#ShowImages([im1ScaledUp.image,im2.image,im2.image - im1ScaledUp.image],[f&quot;Aligned image ({im1ScaledUp.distance} mm)&quot;,f&quot;Image ({im2.distance} mm)&quot;,f&quot;Difference between of the two images&quot;]) </span>

    <span class="n">AddSpacePrint</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculated:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">warp_mat_calc</span><span class="p">)</span>
    <span class="n">AddSpacePrint</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ECC:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">warp_matrix</span><span class="p">)</span>

    <span class="c1">#Matrix to be used for calculations and the matrix returned</span>
    <span class="n">ShiftMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1">#Changing the matrix to be the final one </span>
    <span class="n">ShiftMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">warp_mat_calc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">warp_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">ShiftMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">warp_mat_calc</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">warp_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ShiftMatrix</span></div>

<div class="viewcode-block" id="CalcShiftMM">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.CalcShiftMM">[docs]</a>
<span class="k">def</span> <span class="nf">CalcShiftMM</span><span class="p">(</span><span class="n">imObj1</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">,</span><span class="n">imObj2</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">,</span><span class="n">ShiftMatrix</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">maxDistance</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span><span class="n">dsd</span><span class="p">:</span><span class="nb">float</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes two `ImageObject` and calculates the real life shift to align the detector.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `imObj1 : ImageObject`</span>
<span class="sd">        the image object with smaller distance than `imObj2`.</span>

<span class="sd">    `imObj2 : ImageObject`</span>
<span class="sd">        the image object with larger distance than `imObj1`.</span>

<span class="sd">    `ShiftMatrix : np.ndarray`</span>
<span class="sd">        the shift matrix between the images.</span>
<span class="sd">    </span>
<span class="sd">    `maxDistance : float`</span>
<span class="sd">        the maximum distance in millimeter.    </span>

<span class="sd">    `dsd : float`</span>
<span class="sd">        the detector-source distance.   </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `Tuple[float,float]`</span>
<span class="sd">        the x and y position wrapped in a tuple.</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="c1">#Translate shift from pixels to mm</span>
    <span class="n">xShift</span> <span class="o">=</span> <span class="n">TranslatePixeltoMM</span><span class="p">(</span><span class="n">imObj1</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SINGLE_PIXEL_SIZE_MILLIMETER</span><span class="p">,</span><span class="n">ShiftMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="c1">#/imObj1.settings.GRID_MILLIMETER_LENGTH #Side opposite</span>
    <span class="n">yShift</span> <span class="o">=</span> <span class="n">TranslatePixeltoMM</span><span class="p">(</span><span class="n">imObj1</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">SINGLE_PIXEL_SIZE_MILLIMETER</span><span class="p">,</span><span class="n">ShiftMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="c1">#/imObj1.settings.GRID_MILLIMETER_LENGTH #Side opposite </span>

    <span class="c1">#Difference in distance</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">imObj2</span><span class="o">.</span><span class="n">distance</span> <span class="o">-</span> <span class="n">imObj1</span><span class="o">.</span><span class="n">distance</span> <span class="c1">#Adjacent</span>

    <span class="c1">#Use inverse tan to find angle </span>
    <span class="n">xAngle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">xShift</span><span class="o">/</span><span class="n">distance</span><span class="p">)</span>
    <span class="n">yAngle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">yShift</span><span class="o">/</span><span class="n">distance</span><span class="p">)</span>

    <span class="c1">#Angle should apply to the triangle from the source to detector dsd/distance * x/y shift</span>
    <span class="n">mmShiftX</span> <span class="o">=</span> <span class="p">(</span><span class="n">dsd</span><span class="o">/</span><span class="n">distance</span><span class="p">)</span> <span class="o">*</span> <span class="n">xShift</span>
    <span class="n">mmShiftY</span> <span class="o">=</span> <span class="p">(</span><span class="n">dsd</span><span class="o">/</span><span class="n">distance</span><span class="p">)</span> <span class="o">*</span> <span class="n">yShift</span> 

    <span class="c1">#mmShiftX = (dsd + imObj1.distance + maxDistance) * np.tan(xAngle)</span>
    <span class="c1">#mmShiftY = (dsd + imObj1.distance + maxDistance) * np.tan(yAngle)</span>
    
    <span class="c1"># AddSpacePrint()</span>
    <span class="c1"># print(&quot;print x shift &quot;,np.round(xShift,3))</span>
    <span class="c1"># print(&quot;print y &quot;,np.round(yShift,3))</span>
    <span class="c1"># print(&quot;print distance &quot;,np.round(distance,3))</span>
    <span class="c1"># print(&quot;angle x&quot;,np.round(xAngle,3))</span>
    <span class="c1"># print(&quot;angle y&quot;,np.round(yAngle,3))</span>
    <span class="c1"># print(&quot;mm shift x&quot;,np.round(mmShiftX,3))</span>
    <span class="c1"># print(&quot;mm shift y&quot;,np.round(mmShiftY,3))</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">mmShiftX</span><span class="p">,</span><span class="n">mmShiftY</span><span class="p">]</span> </div>

<div class="viewcode-block" id="FindCenterHole">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.FindCenterHole">[docs]</a>
<span class="k">def</span> <span class="nf">FindCenterHole</span><span class="p">(</span><span class="n">imObj</span><span class="p">:</span><span class="n">ImageObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Point</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes an `ImageObject` and finds the hole on the image through thresholding and return the x and y position.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `imObj : ImageObject`</span>
<span class="sd">        the image object with the hole on it.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `Point`</span>
<span class="sd">        point object with the x and y position.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span><span class="n">thresh</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">imObj</span><span class="o">.</span><span class="n">image</span><span class="p">,</span><span class="mi">250</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">THRESH_BINARY</span><span class="p">)</span>
    
    <span class="n">contours</span><span class="p">,</span> <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_NONE</span><span class="p">)</span>

    <span class="n">contourImage</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">thresh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">*</span><span class="mi">0</span><span class="p">,</span><span class="n">contours</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,(</span><span class="mi">125</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">#Worst case is 4 contours of the hole because it is split up</span>
    
    <span class="c1">#Find area and combine with the element to create tuple</span>
    <span class="n">areasAndContours</span> <span class="o">=</span>  <span class="p">[[</span><span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">item</span><span class="p">),</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">contours</span> <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">]</span>
    
    <span class="c1">#Sort the tuple based on area, aac (areas and contours)</span>
    <span class="n">aacSorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">areasAndContours</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1">#Since worst case is 4 parts of the hole on the image, we take out the 4 last elements</span>
    <span class="n">aacSorted</span> <span class="o">=</span> <span class="n">aacSorted</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>

    <span class="c1">#Check to see what case we are working with, checking based on largest area and comparing with the 3 other</span>
    <span class="c1">#Tolarance 50%</span>
    <span class="n">tolarance</span> <span class="o">=</span> <span class="n">aacSorted</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">aacSorted</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span>

    <span class="c1">#Filter out what is smaller than the tolarance</span>
    <span class="n">filteredAC</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tolarance</span><span class="p">,</span><span class="n">aacSorted</span><span class="p">))</span>
    
    <span class="c1">#Go back to contours only, ac (areaContour)</span>
    <span class="n">holeContours</span> <span class="o">=</span> <span class="p">[</span><span class="n">ac</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ac</span> <span class="ow">in</span> <span class="n">filteredAC</span> <span class="p">]</span> 

    <span class="c1">#Draw on empty image to get contours</span>
    <span class="n">filtered</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">thresh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">*</span><span class="mi">0</span><span class="p">,</span><span class="n">holeContours</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,(</span><span class="mi">255</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">#Fill contours on image</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">fillPoly</span><span class="p">(</span><span class="n">filtered</span><span class="p">,</span><span class="n">holeContours</span><span class="p">,(</span><span class="mi">255</span><span class="p">))</span>

    <span class="c1">#Find all the filled pixels</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">filtered</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span>

    <span class="c1">#Take mean of indices    </span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1">#Draw point </span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">filtered</span><span class="p">,(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span><span class="mi">0</span><span class="p">,(</span><span class="mi">125</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">ShowImages</span><span class="p">([</span><span class="n">imObj</span><span class="p">,</span><span class="n">ImageObject</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span><span class="n">imObj</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span><span class="n">imObj</span><span class="o">.</span><span class="n">distance</span><span class="p">),</span><span class="n">ImageObject</span><span class="p">(</span><span class="n">contourImage</span><span class="p">,</span><span class="n">imObj</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span><span class="n">imObj</span><span class="o">.</span><span class="n">distance</span><span class="p">),</span><span class="n">ImageObject</span><span class="p">(</span><span class="n">filtered</span><span class="p">,</span><span class="n">imObj</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span><span class="n">imObj</span><span class="o">.</span><span class="n">distance</span><span class="p">)],[</span><span class="s2">&quot;before&quot;</span><span class="p">,</span><span class="s2">&quot;thresh&quot;</span><span class="p">,</span><span class="s2">&quot;contour&quot;</span><span class="p">,</span><span class="s2">&quot;filtered contours&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="MakeReader">
<a class="viewcode-back" href="../../../functions.Detector_detection_functions.html#functions.Detector_detection_functions.Detector_detection_functions.MakeReader">[docs]</a>
<span class="k">def</span> <span class="nf">MakeReader</span><span class="p">(</span><span class="n">fileType</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImageReader</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory method that takes a filetype and create the appropriate `ImageReader`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    `fileType : str`</span>
<span class="sd">        the file extension of the images.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `ImageReader`</span>
<span class="sd">        the interface with the ReadImage method that can read the input file extension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Create factory</span>
    <span class="n">readerFactory</span> <span class="o">=</span> <span class="n">ReaderFactory</span><span class="p">()</span>

    <span class="k">if</span><span class="p">(</span><span class="n">fileType</span> <span class="o">==</span> <span class="s2">&quot;.tif&quot;</span> <span class="ow">or</span> <span class="n">fileType</span> <span class="o">==</span> <span class="s2">&quot;.tiff&quot;</span><span class="p">):</span>
        <span class="c1">#tif based</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">readerFactory</span><span class="o">.</span><span class="n">CreateReader</span><span class="p">(</span><span class="n">ReaderType</span><span class="o">.</span><span class="n">TIFF</span><span class="p">)</span>

    <span class="k">elif</span><span class="p">(</span><span class="n">fileType</span> <span class="o">==</span> <span class="s2">&quot;.txt&quot;</span><span class="p">):</span>
        <span class="c1">#txt based</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">readerFactory</span><span class="o">.</span><span class="n">CreateReader</span><span class="p">(</span><span class="n">ReaderType</span><span class="o">.</span><span class="n">TXT</span><span class="p">)</span>

    <span class="k">elif</span><span class="p">(</span><span class="n">fileType</span> <span class="o">==</span> <span class="s2">&quot;.npy&quot;</span><span class="p">):</span>
        <span class="c1">#numpy based</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">readerFactory</span><span class="o">.</span><span class="n">CreateReader</span><span class="p">(</span><span class="n">ReaderType</span><span class="o">.</span><span class="n">NPY</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reader</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Detector Detection</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">src</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Mustafa A..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>